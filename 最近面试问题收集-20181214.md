# 最近面试问题收集

### 1.LocalStorage，SessionStorage，Cookie的区别以及使用的场景

| 储存方式       | 储存大小 | 清除                                         | 使用场景                                             |
| -------------- | -------- | -------------------------------------------- | ---------------------------------------------------- |
| cookie         | 4K左右   | 可以设置失效时间                             | 判断用户是否登陆过网站，记住密码等                   |
| localStorage   | 5M左右   | 除非被清除或者卸载浏览器，否则永久保存；     | 适合长期保存在本地的数据，比如说夜间模式，主题模式等 |
| sessionStorage | 5M左右   | 仅在当前会话下有效，关闭页面或浏览器后被清除 | 网上商城中的购物车，ajax的数据缓存                   |

### 2.this是什么，this的4个指向以及改变this指向的方法

​	this代表函数运行时候，自动生成的一个内部对象，只能在函数内使用。

this的四种指向：

a.如果是一般函数,this指向全局对象window;

b.在严格模式下"use strict",为undefined.

c.对象的方法里调用,this指向调用该方法的对象.

d.构造函数里的this,指向创建出来的实例.

改变this指向的方式：

改变this的指向并且执行调用函数

.call(),  call(thisScope, arg1, arg2, arg3...)

.apply(), apply(thisScope, [arg1, arg2, arg3...]);两个参数

而bind 改变this的指向，返回的是函数

.bind()  bind(thisScope, arg1, arg2, arg3...)

### 3.面向对象

​	面向对象的编程是以对象为中心,以消息为驱动,所以程序=对象+消息。

面向对象的两个特性：继承和封装

封装就是将一类事物的属性和行为抽象成一个类,使其属性私有化,行为公开化,提高了数据的隐秘性的同时,使代码模块化。这样做使得代码的复用性更高。  

继承则是进一步将一类事物共有的属性和行为抽象成一个父类,而每一个子类是一个特殊的父类--有父类的行为和属性,也有自己特有的行为和属性。这样做扩展了已存在的代码块,进一步提高了代码的复用性。  

### 4.原型链

​	当访问一个对象的某个属性时，会先从该函数本身属性上找，如果没有找到，则会在他的 _ proto _隐式属性（即构造函数的prototype）上去找，如果还没有找到的话，则就会再去prototyep的 _ proto _ 中去找，这样一层一层向上查找就会形成一个链式结构，就称之为原型链。

### 5.vue的双向绑定的底层原理

​	vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过`Object.defineProperty()`来劫持各个属性的`setter`，`getter`，在数据变动时发布消息给订阅者，触发相应的监听回调。

​	1.observer:能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者。

​	2.compile:对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。

​	3.watcher:作为连接observer和compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图。

### 6.用过哪些ui，哪些是基于vue

| ui框架            | 基于  |
| ----------------- | ----- |
| vux               | vue   |
| vonic             | vue   |
| Muse-ui           | vue   |
| Mint UI           | vue   |
| Material-UI       | React |
| React Desktop     | React |
| Ant-design        | React |
| Semantic-UI-React | React |
|                   |       |

### 7.DNS解析过程

​	DNS是“域名系统”，它所提供的服务是用来将主机名和域名转换为IP地址的工作。

a.客户机提出域名解析请求,并将该请求发送给本地的域名服务器. 　　

b.当本地的域名服务器收到请求后,就先查询本地的缓存,如果有该纪录项,则本地的域名服务器就直接把查询的结果返回. 　　

c.如果本地的缓存中没有该纪录,则本地域名服务器就直接把请求发给根域名服务器,然后根域名服务器再返回给本地域名服务器一个所查询域(根的子域)的主域名服务器的地址. 　　

d.本地服务器再向上一步返回的域名服务器发送请求,然后接受请求的服务器查询自己的缓存,如果没有该纪录,则返回相关的下级的域名服务器的地址. 　　

e.重复第四步,直到找到正确的纪录. 　　

f.本地域名服务器把返回的结果保存到缓存,以备下一次使用,同时还将结果返回给客户机.

### 8.介绍一下React

可以根据个人项目介绍，然后说用到什么，首先creat-react-app创建react脚手架，然后react-router配置全局的路由，还有分类页之类的可以利用二级路由实现局部刷新的效果，利用react-redux进行组件的通信等，然后还可以扯组件的通信，父传子用props，子传父可以用redux或者自己封装一个发布订阅模式，利用$on和$emit对进行通信，跨组件通信还可以利用状态提升，再不济也可以用sessionStorage或者localStorage这种，跨组件通信一般都是通过第三方去协助你通信的。

### 9.虚拟Dom及其作用/好处

​	虚拟DOM其实就是用JS来模拟DOM结构，把DOM的变化操作放在JS层来做，尽量减少对DOM的操作，然后对比前后两次的虚拟DOM的变化，只重新渲染变化了的部分，而没有变化的部分则不会重新渲染。

1.避免大量无谓的计算量，解决浏览器性能问题

2.操作虚拟dom即js对象远快于操作真实dom

### 10.你做了哪些前端优化，页面性能优化

1.在一个大的组件中，把所有数据请求回来缓存到sessionStorage和localStorage里面，然后分发到小组件。

2.精灵图，减少图片请求

3.尽量引入外部css和外部js，保持页面结构的清晰明了。

4.加入数据量大的时候可以将数据分组，然后按需加载更多。懒加载，加载更多。

5.预加载，预加载是在浏览器空闲时候请求可能会用到的页面内容（如图像，样式和脚本）。

### 11.vue在不同机型下如何兼容

安卓低版本手机是不支持ES6语法的，还有少部分低版本安卓不支持小部分的ES5语法，因此vue使用的是ES6语法，所以会导致页面渲染问题。

1、npm 安装

npm install babel-polyfill

npm install es6-promise

2、main.js引入 

import 'babel-polyfill'

import Es6Promise from 'es6-promise'

require('es6-promise').polyfill()

Es6Promise.polyfill()

3、更改 webpack.base.conf.js 文件中的入口

entry: {

app: ["babel-polyfill", "./src/main.js"]

},

### 12.git版本1.0.0的错误如何在2.0.0中修复，目前线上版本是2.0.0（Git如何修复已发布版本的Bug？）
1、回退到出 Bug 的版本

首先，查看出bug版本的详细信息（以0.1.1为例）。

```git show v0.1.1```

其中 xxxxxxxxxxxxxxxxxxxxxxxxxxx 就是版本发布时的 Commit ID。回退到 v0.1.1：

此时查看目录，会发现所有源代码都已经回退到了当时的版本。

2、新建 bugfix 分支

建好 bugfix 分支后，需要将原来的分支（我这里是 master 分支）前进到最新版本（否则它就一直停留在 v0.1.1 了）。

此时你会发现，master 分支为当前最新进度，bugfix 分支为出 Bug 的版本。

3、修改 Bug

接下来就是切换到 bugfix 分支：

修改完 Bug 后，正常 git add & git commit 即可，并将 bugfix 分支推送到远程 Git服务器。

4、重打 Tag

将改好 Bug 的代码重新打上 v0.1.1 的 tag。这里需要注意的是，默认情况下 git 会给 v0.1.1 附上一个当前的时间戳，从而会出现 v0.1.1 的发布时间比 v0.4.2 晚的情况，GitHub 的 Release 页面则会认为 v0.1.1 是最新的版本。

因此我们需要自行“伪造”一个提交日期，即为原先 v0.1.1 的提交日期即可：

```GIT_COMMITTER_DATE="2017-10-14 23:27" git tag -f v0.1.1 -m "The V0.1.1 Release"```

将修改后的 tag 推送到远程 GitHub（强制更新）：

5、Merge

最后需要将 bugfix 分支归并到 master 分支。

解决冲突、修改完成后正常 git add & git commit 即可。

6、清理

后续的一些清理工作即删除临时的 bugfix 分支（本地以及远程）：

### 13.rem的生成原理

### 14.rem和px的换算

1rem等于html根元素设定的font-size的px值，假如我们在css里面设定下面的css。

```html{font-size:14px}```

那么后面的CSS里面的rem值则是以这个14来换算，例如设定一个div宽度为3rem,高度为2.5rem.则它换算成px为width:42px.height:35px，同理，假如一个设计稿为宽度42px,高度为35px，则换成成rem，则是42/14=3rem，35/14=2.5rem。

如果css里面没有设定html的font-size，则默认浏览器以1rem=16px来换算。

### 15.vue的路由复制下来到别的地方打开为什么为空值

### 16.post和get的请求在node中是怎么拿到的

### 17.在使用vue如何布局

### 18.sessionStorage能否实现cookie的效果

### 19.加载页面，再次重新加载的时候，不用缓存怎么做

### 20.vue和react的区别

### 21.引用数据类型和基础书类型的区别

### 22.浏览器如何解析的

### 23.es6有哪些新特性

### 24.html5有哪些新特性

### 25.hash路由的#怎么去掉

### 26.vue框架中的@代表什么？

### 27.ES6中什么和闭包很像？

### 28.数组去重的方法

### 29.字符串有哪些方法

### 30.数组有哪些方法？

### 31.大组件里面引入了很多小组件，如何使小组件进行异步加载

### 32.undefined和null区别

### 33.介绍一下vue

### 34.介绍以下你的项目

### 35.闭包的理解以及使用场景

### 36.jQuery获取兄弟节点

### 37.link和@import的区别

### 38.延时加载和异步加载的区别

### 39.做项目的思路

### 40.有没有上线部署过

### 41.如果上线的时候发现白屏了，怎么处理

### 42.typeof和indexof的区别

### 43.用过哪些websocket的api

### 44.vue的组件通信

### 45.css3新特性以及使用场景

### 46.你在使用vue的过程中有使用过哪些组件化开发？

### 47.你在后端的接口什么样的数据结果会开心？

### 48.cookie使根据什么判断用户登录状态？

### 49.端对端你了解么？

### 50.假如项目要上线了，但是后端数据还没有来？

### 51.a标签的优先级

### 52.如何用js把一个很大的图片压缩

### 53.如何监听全局的异常，包括浏览器崩溃，服务器问题等等

### 54.webpack插件的底层原理你有了解过么？

### 55.swiper的底层原理？

### 56.vue如何捕获异常

### 57.vue如何定义全局变量

### 58.在谷歌和安卓收集上运行正常，但是在ios出现白屏？

### 59.某一条url请求错误了你如何调试这个问题

### 60.react一下子返回了一万多条信息，一万多条dom，一下子卡死了，如何解决？

### 61.查询字符串里面最多的字符

### 62.前后端分离么？那你们跨域问题怎么解决的？

### 63.开发流程，比如说你到后期怎么和安卓或者ios交互

### 64.有没有遇到过在各类型手机上出现样式兼容性问题，比如说哪里高了或者低了，怎么解决的？

### 65.v-model的实现原理？

### 66.promise的底层原理？

### 67.vue的插槽？

### 68.异步加载组件？

### 69.怎么预先加载组件？

### 70.图片的预加载？

### 71.重新渲染要会用到那几个生命周期？
